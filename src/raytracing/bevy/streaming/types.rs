use crate::{
    boxtree::{types::PaletteIndexValues, V3c, V3cf32},
    raytracing::BoxTreeRenderData,
    spatial::Cube,
};
use bevy::{ecs::resource::Resource, tasks::Task};
use bimap::BiHashMap;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, RwLock},
};

/// Brick ownership, complete with brick position where relevant
#[derive(Debug, Clone, Eq)]
pub(crate) enum BrickOwnedBy {
    None,
    NodeAsChild(u32, u8, V3c<u32>),
    NodeAsMIP(u32),
}

/// Thread safe container stotring which node owns which brick within the GPU
pub(crate) type BrickOwnership = Arc<RwLock<BiHashMap<usize, BrickOwnedBy>>>;

/// An async task calculating what nodes does the current viewport contains
#[derive(Resource)]
pub(crate) struct UploadQueueUpdateTask(pub(crate) Task<()>);

/// An update to a single brick inside the GPU cache in a view
#[derive(Default)]
pub(crate) struct BrickUpdate<'a> {
    pub(crate) brick_index: usize,
    pub(crate) data: &'a [PaletteIndexValues],
}

/// An update generated by a request to insert a node, brick or MIP
#[derive(Default)]
pub(crate) struct CacheUpdatePackage<'a> {
    /// true if the view needs a resize
    pub(crate) allocation_failed: bool,

    /// The cache index of the node inserted in this operation
    pub(crate) added_node: Option<usize>,

    /// The bricks updated during the request
    pub(crate) brick_updates: Vec<BrickUpdate<'a>>,

    /// The list of modified nodes during the operation
    /// with updated child connections for each node in a bitstring
    /// where each bit set matches the correcponding child
    pub(crate) modified_nodes: Vec<(usize, u64)>,
}

/// Information about the bricks and nodes available on the GPU
/// as well as the bricks and nodes to upload
#[derive(Debug, Clone)]
pub(crate) struct UploadQueueTargets {
    /// Map to connect brick indexes in GPU data to their counterparts in the tree
    pub(crate) brick_ownership: BrickOwnership,

    /// Map to connect tree node keys to node meta indexes
    pub(crate) node_key_vs_meta_index: BiHashMap<usize, usize>,

    /// Map to connect nodes index values inside the GPU to their parents
    /// Mapping is as following: node_index -> (parent_index, child_sectant)
    pub(crate) node_index_vs_parent: HashMap<usize, (usize, u8)>,

    /// A set containing all nodes which should be on the GPU
    pub(crate) nodes_to_see: Arc<RwLock<HashSet<usize>>>,
}

#[derive(Debug, Clone)]
pub(crate) struct UploadQueueStatus {
    /// Access stack of the node and its target sectant
    /// which is being evaluated for upload
    pub(crate) target_node_stack: Vec<(usize, u8, Cube)>,

    /// List of bricks to upload to the GPU
    pub(crate) bricks_to_upload: Vec<BrickOwnedBy>,

    /// Index pointing inside GPU data where the search will start
    /// for the next brick to be overwritten
    pub(crate) victim_brick: usize,

    /// Index pointing inside GPU data where the search will start
    /// for the next node to be overwritten
    pub(crate) victim_node: usize,

    /// The number of colors uploaded to the GPU
    pub(crate) uploaded_color_palette_size: usize,
}

#[derive(Debug, Resource)]
pub struct BoxTreeGPUDataHandler {
    /// Tells the handler how many nodes to upload in one frame
    pub node_uploads_per_frame: usize,

    /// Tells the handler how many bricks to upload in one frame
    pub brick_uploads_per_frame: usize,

    /// Tells the handler how far away to look for bricks to find
    /// the furthest to unload
    pub brick_unload_search_perimeter: usize,

    /// The capacity for nodes within the view
    pub(crate) nodes_in_view: usize,

    /// The capacity for bricks within the view
    pub(crate) bricks_in_view: usize,

    /// The area on which node and brick upload is based on
    pub(crate) upload_range: Cube,

    /// The data the GPU displays
    pub(crate) render_data: BoxTreeRenderData,

    /// Target and progress data for GPU uploads
    pub(crate) upload_targets: UploadQueueTargets,

    /// Target and progress data for GPU uploads
    pub(crate) upload_state: UploadQueueStatus,

    /// Center and viewing distance of the viewport that needs to be set
    pub(crate) pending_upload_queue_update: Option<(V3cf32, f32)>,
}

#[cfg(test)]
mod streaming_type_tests {
    use std::hash::{DefaultHasher, Hash};

    use crate::{boxtree::V3c, raytracing::bevy::streaming::BrickOwnedBy};

    #[test]
    fn test_brick_ownership_hash() {
        assert_eq!(
            BrickOwnedBy::NodeAsChild(5, 6, V3c::new(5, 5, 5)).hash(&mut DefaultHasher::new()),
            BrickOwnedBy::NodeAsChild(5, 6, V3c::new(0, 0, 0)).hash(&mut DefaultHasher::new())
        )
    }
}
